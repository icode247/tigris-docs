import NextjsGuidesSection from "@site/src/components/NextjsGuidesSection";
import createNextAppOutput from "!!raw-loader!./_createNextAppOutput";
import runNextAppOutput from "!!raw-loader!./_runNextAppOutput";
import tigrisCreateAppOutput from "!!raw-loader!./_tigrisCreateAppOutput";
import CodeBlock from "@theme/CodeBlock";
import TerminalWindow from "@site/src/components/TerminalWindow/index";
import Installation from "../../includes/_install_cloud_login.mdx";

# Tigris and Next.js

Tigris is the scalable real-time backend for Next.js applications. Build
data-rich features, seamlessly implement search, and easily connect
serverless functions.

## Getting started

<Installation />

### Initialize your Next.js app

Next.js allows you to bootstrap apps using [create-next-app](https://nextjs.org/docs/api-reference/create-next-app)
utility

```shell
npx create-next-app --example with-tigris
```

<details>
  <summary>Output</summary>
  <TerminalWindow>
    <CodeBlock language="shell">{createNextAppOutput}</CodeBlock>
  </TerminalWindow>
</details>

### Add the Tigris cloud credentials

Our application requires credentials to be able to use Tigris. Let's generate the credentials and
add them to the environment file.

#### Generating application credentials

```shell
tigris create application starter-todo-app "Starter todo application"
```

This command will create the credentials and print it on the terminal screen

```mdx-code-block
<TerminalWindow>
<CodeBlock language="shell">{tigrisCreateAppOutput}</CodeBlock>
</TerminalWindow>
```

We will use the `id` and `secret` from the output and add them as `TIGRIS_CLIENT_ID` and `TIGRIS_CLIENT_SECRET`
respectively in the file `.env.development.local` in `my-tigris-app` directory.

```shell
cd my-tigris-app
```

Now, let's create the environment file `.env.development.local` and add the application credentials generated above to it

```dotenv title=.env.development.local
TIGRIS_URI=api.preview.tigrisdata.cloud
TIGRIS_CLIENT_ID=client_id_here
TIGRIS_CLIENT_SECRET=client_secret_here
```

### Defining the data model{#data-model}

Tigris stores data records as documents. Documents are analogous to JSON objects grouped together in
a [Collection](/overview/databases). Our to-do list app has a single collection `todoItems` that
stores to-do items as documents.

This to-do app follows a convention of having models and schemas in `models/tigris` directory. Within
the directory we have `todoStarterApp` directory that will be our database name and the file
`todoItems.ts` describes the schema for collection named `todoItems`.

Let's add following highlighted code to `models/tigris/todoStarterApp/todoItems.ts`:

```ts title=models/tigris/todoStarterApp/todoItems.ts
import {
  TigrisCollectionType,
  TigrisDataTypes,
  TigrisSchema,
} from "@tigrisdata/core/dist/types";

export const COLLECTION_NAME = "todoItems";

// highlight-start
export interface TodoItem extends TigrisCollectionType {
  id?: number;
  text: string;
  completed: boolean;
}

export const TodoItemSchema: TigrisSchema<TodoItem> = {
  id: {
    type: TigrisDataTypes.INT32,
    primary_key: { order: 1, autoGenerate: true },
  },
  text: { type: TigrisDataTypes.STRING },
  completed: { type: TigrisDataTypes.BOOLEAN },
};
// highlight-end
```

We defined a data model named `TodoItem` to use in our application and created `TodoItemSchema` as a
`TigrisSchema` for the data model. In the next section we show how these data models are used to
automatically define databases and collections, and how the schemas are kept in sync with the models.

### Setting up automatic schema management

Tigris makes it really easy to [automate schema management](/typescript/documents/schema-bootstrap)
by using the models defined in your project.
In this section we will setup the code that is responsible for automatically managing schemas
corresponding to the [data model defined above](#data-model).
Let's see how this works by adding following code to
`scripts/setup.ts` file:

```ts title=scripts/setup.ts
import { Tigris } from "@tigrisdata/core";
import { loadEnvConfig } from "@next/env";

// Run the config loader only when not executing within next runtime
if (process.env.NODE_ENV === undefined) {
  if (process.env.APP_ENV === "development") {
    loadEnvConfig(process.cwd(), true);
  } else if (process.env.APP_ENV === "production") {
    loadEnvConfig(process.cwd());
  }
}

async function main() {
  // highlight-start
  // setup client and register schemas
  const tigrisClient = new Tigris();
  await tigrisClient.registerSchemas("models/tigris");
  // highlight-end
}

main();
```

The main thing to see here is the `registerSchemas()` method that accepts a path which is then scanned to
derive databases and collections that need to be created. We registered `models/tigris` directory with
Tigris client that includes a `todoStarterApp` directory and `todoItems.ts` file with `TodoItemSchema`
defined.

A database named `todoStarterApp` (derived from directory name) and a collection named `todoItems`
(derived from filename) will be created conforming to `TodoItemSchema`. If the collection
already exists, it will apply schema changes, if any, to that collection.

See, how you don't have to explicitly "create a database and collection" or "make changes to
collection schemas"; everything is handled by `registerSchemas()` for you.

Let's further automate this process by always executing the script at build time. Open
`package.json` in editor and add following highlighted scripts:

```json title=package.json
  "scripts": {
    // highlight-next-line
    "predev": "APP_ENV=development npm run setup",
    "dev": "next dev",
    "build": "next build",
    // highlight-next-line
    "postbuild": "APP_ENV=production npm run setup",
    "start": "next start",
    "clean": "rm -rf node_modules .next",
    // highlight-next-line
    "setup": "npx ts-node scripts/setup.ts"
  }
```

We added a `setup` command to run `scripts/setup.ts` and then added a `predev` hook to setup
schemas right before `dev` command is executed. Additionally, we added a `postbuild` hook to
setup schemas in production environment right after `build`. Now, all your databases and
collections will be in sync with model definitions in code.

:::tip No more schema management
You don't have to worry about applying schema changes anymore, managing schema is now a part of your
development workflow. Read more about this automated schema management [here](/typescript/documents/schema-bootstrap).
:::




### Run

Run the app and see it automatically create your databases and collections

```shell
npm run dev
```

<details>
  <summary>Output</summary>
  <TerminalWindow>
    <CodeBlock language="shell">{runNextAppOutput}</CodeBlock>
  </TerminalWindow>
</details>

:tada: Your fullstack webapp is ready and accessible on `localhost:3000` in the browser.

## Guides

Here you will find a set of guides to help you easily build a dynamic data-rich
Next.js app with Tigris.

<NextjsGuidesSection className="two-cols" />
